from typing import Dict, List, Optional
import json
import numpy as np
from sklearn.ensemble import RandomForestClassifier
from sklearn.feature_extraction.text import TfidfVectorizer
from sklearn.model_selection import train_test_split
from sklearn.metrics import classification_report
import joblib
import os

class VulnerabilityClassifier:
    def __init__(self, model_path: Optional[str] = None):
        self.vectorizer = TfidfVectorizer(max_features=10000)
        self.classifier = RandomForestClassifier(n_estimators=100, random_state=42)
        self.model_path = model_path or os.path.join(
            os.path.dirname(__file__),
            "vulnerability_model.joblib"
        )
        self.vectorizer_path = os.path.join(
            os.path.dirname(__file__),
            "vectorizer.joblib"
        )
        self._load_model()

    def _load_model(self):
        """Load pre-trained model if available"""
        try:
            if os.path.exists(self.model_path):
                self.classifier = joblib.load(self.model_path)
            if os.path.exists(self.vectorizer_path):
                self.vectorizer = joblib.load(self.vectorizer_path)
        except Exception as e:
            print(f"Error loading model: {e}")

    def save_model(self):
        """Save trained model"""
        joblib.dump(self.classifier, self.model_path)
        joblib.dump(self.vectorizer, self.vectorizer_path)

    def train(self, training_data: List[Dict]):
        """Train the vulnerability classifier"""
        X = [item['description'] for item in training_data]
        y = [item['severity'] for item in training_data]

        # Transform text data
        X_vectorized = self.vectorizer.fit_transform(X)

        # Split dataset
        X_train, X_test, y_train, y_test = train_test_split(
            X_vectorized, y, test_size=0.2, random_state=42
        )

        # Train classifier
        self.classifier.fit(X_train, y_train)

        # Evaluate
        y_pred = self.classifier.predict(X_test)
        report = classification_report(y_test, y_pred)

        # Save trained model
        self.save_model()

        return {
            "training_samples": len(X),
            "evaluation_report": report
        }

    def predict(self, vulnerability_data: Dict) -> Dict:
        """Predict vulnerability severity and provide recommendations"""
        description = vulnerability_data.get('description', '')
        if not description:
            return {"error": "No description provided"}

        # Transform input
        X = self.vectorizer.transform([description])

        # Predict severity
        severity = self.classifier.predict(X)[0]
        probability = np.max(self.classifier.predict_proba(X))

        return {
            "severity": severity,
            "confidence": float(probability),
            "recommendations": self._generate_recommendations(vulnerability_data, severity)
        }

    def _generate_recommendations(self, vulnerability_data: Dict, severity: str) -> List[str]:
        """Generate remediation recommendations based on vulnerability type and severity"""
        recommendations = []

        # Basic severity-based recommendations
        if severity == "critical":
            recommendations.append("Immediate remediation required")
            recommendations.append("Consider temporary system shutdown if exploitation detected")
        elif severity == "high":
            recommendations.append("Prioritize fix within 24-48 hours")
            recommendations.append("Implement temporary mitigation measures")
        elif severity == "medium":
            recommendations.append("Plan remediation within 1-2 weeks")
        else:
            recommendations.append("Address during regular maintenance cycle")

        # Vulnerability type-specific recommendations
        vuln_type = vulnerability_data.get('type', '').lower()
        if 'sql injection' in vuln_type:
            recommendations.extend([
                "Implement prepared statements",
                "Use input validation and sanitization",
                "Apply principle of least privilege to database users"
            ])
        elif 'xss' in vuln_type:
            recommendations.extend([
                "Implement Content Security Policy (CSP)",
                "Use proper output encoding",
                "Sanitize user input"
            ])
        elif 'rce' in vuln_type:
            recommendations.extend([
                "Avoid using dangerous functions",
                "Implement strict input validation",
                "Use allowlist for permitted commands"
            ])

        return recommendations

    def batch_predict(self, vulnerabilities: List[Dict]) -> List[Dict]:
        """Process multiple vulnerabilities in batch"""
        results = []
        for vuln in vulnerabilities:
            prediction = self.predict(vuln)
            results.append({
                "vulnerability": vuln,
                "prediction": prediction
            })
        return results

    def update_model(self, new_training_data: List[Dict]):
        """Update existing model with new training data"""
        # Load existing training data if available
        existing_data = []
        try:
            if os.path.exists("training_data.json"):
                with open("training_data.json", "r") as f:
                    existing_data = json.load(f)
        except Exception:
            pass

        # Combine existing and new data
        combined_data = existing_data + new_training_data

        # Save updated training data
        with open("training_data.json", "w") as f:
            json.dump(combined_data, f)

        # Retrain model
        return self.train(combined_data)

    def evaluate_prediction(self, prediction: Dict, actual_severity: str) -> Dict:
        """Evaluate prediction accuracy and update model if necessary"""
        return {
            "predicted_severity": prediction["severity"],
            "actual_severity": actual_severity,
            "confidence": prediction["confidence"],
            "accuracy": prediction["severity"] == actual_severity
        }
